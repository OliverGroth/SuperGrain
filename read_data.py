import matplotlib.pyplot as plt
import os
import hashlib
import struct
import numpy as np
from PIL import Image

"""

This is a script that sort of hightlights how we can read the data from the .tbin files that SmartGrain outputs.
We want to do  this because we can from this information create the segmented images that we can train on as ground truths.
Take parts of this code as you wish, or if you want to write a faster/more optimized version.

Which specific bytes to read in hex-binary file was found by Carl, and his description can be found in the folder as a
 pdf, if you're curious. 

All length values in here are in pixels, which needs to be scaled with a scaling factor.
This is why there is a ruler in the images. The scaling factor differs image to image.
Not sure if it can be found in the tbin files, but definitely in the csv with analyzed data. 
Right now it is not used, so all lengths are currently in pixels
The scale in is [mm/pixel], should be converted when comparing to csv-values.
"""

file = "$$IMG_9291.tbin" # Path to the tbin file of the analyzed sample

def read_seed(start_byte,out_hex):
    """
    This function reads the coordinates and some attributes of __one__  seed in an image from a .tbin file generated by
    SmartGrain.

    Inputs:
        start_byte: The first byte to start reading for the current seed
        out_hex: The full raw hexadecimal file, containing all seeds.
    Output:
        seed: a dictionary containing the fields
        ["Centroid", "IS (intersection?)", "Length", "width", "Area", "PL", "Circularity", "Contour"]
        , where Contour contains the coordinates of the pixels at the contour of the seed.
        new_start: The byte to start reading the next seed.
    """
    vals = []
    line = out_hex[start_byte:start_byte+48]
    for i in range(len(line) // 4):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        vals.append(decimal_val)

    vals2 = np.reshape(vals, [6, 2])
    # Bytes 48 through  52 are zeroes.

    # Next are a bunch of properties of the seed as computed by SmartGrain, described below, and stored in attrib.
    # Attributes = ["Centroid", "IS (intersection?)", "Length", "width", "Area", "PL", "Circularity"]
    line = out_hex[start_byte+52:start_byte+52+100]
    attrib = []
    for i in range(len(line) // 8):
        hexval = "".join(line[i * 8:i * 8 + 8][::-1])
        decimal_val = struct.unpack("!d", bytes.fromhex(hexval))[0]
        attrib.append(decimal_val)

    # Read the number of points defining the outline of the seed.
    line = out_hex[start_byte+304:start_byte+308]
    for i in range(len(line) // 4):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        n_points = decimal_val

    # Read the coordinate of the seeds.
    line = out_hex[start_byte+308:start_byte+308 + ((n_points ) * 3 * 4)]
    coords = []
    for i in range((n_points) * 3):
        hexval = "".join(line[i * 4:i * 4 + 4][::-1])
        decimal_val = struct.unpack("!l", bytes.fromhex(hexval))[0]
        coords.append(decimal_val)

    coords2 = np.reshape(coords, [n_points, 3])

    # Compute at which byte to start reading the next seed in the image.
    new_start = start_byte+308 + ((n_points ) * 3 * 4)

    # Store the seed attributes as a dictionary.
    seed = {}
    seed["Centroid"] = np.array([attrib[0], attrib[1]])
    seed["Intersection"] = np.array([attrib[2], attrib[3]])
    seed["Length"] = np.array([attrib[4]])
    seed["Width"] = np.array([attrib[5]])
    seed["Area"] = np.array([attrib[6]])
    seed["PL"] = np.array([attrib[7]])
    seed["Circularity"] = np.array([attrib[8]])
    seed["Contour"] = coords2

    return  seed, new_start

plt.close("all")



file = "$$IMG_9291.tbin"
#file = "Exempeldata/analyzed_data/$$IMG_9291.tbin"

image = Image.open("IMG_9291.JPG")
#image = Image.open("Exempeldata/folder/IMG_9291.JPG")


# Given a filename, start reading the data for all the seeds.
# This is probably an ugly solution programming-wise, but it works. It keeps reading seeds from the tbin file, until the
# new starting byte has reached end-of-file, without knowing how large the file is.
seeds = []
start_byte = 120
i = 0
try:

    # Read the entire hex-file.
    with open(file, "rb") as f:
        buff = f.read()
    out_hex = ['{:02X}'.format(b) for b in buff]

    #Keep reading the data for each seed in the image, until we reach the end.
    # Store them as a list of dictionaries, one for each seed.
    while True: # (don't do this hehe... can probably do something more elegant/smarter)
        seed, start_byte = read_seed(start_byte = start_byte, out_hex = out_hex)
        seeds.append(seed)
        i +=1
        print(f"Read seed no. {i}")
except:
    pass



plt.figure()
areas = []
Circularities = []
areas = []

for seed in seeds:
    plt.plot(seed["Contour"][:,0],seed["Contour"][:,1],'b')
    plt.plot(seed["Centroid"][0], seed["Centroid"][1], 'r.')

    inds = np.where(seed["Contour"][:,2] == 3)
    #plt.plot(seed["Contour"][inds,0][0],seed["Contour"][inds,1][0],'r')
    areas.append(seed["Area"])
    Circularities.append(seed["Circularity"])
#plt.title("This looks weird, right? part of the ruler is segmented. See comment in code.")

areas = np.array(areas)

# Without being careful, SmartGrain can also segment other stuff, e.g., parts of the ruler, or tiny specks
# which shouldn't be considered seeds. The below line removes unreasonably large, and small values.
#  Real seeds seems to, __in this particular camera setup__, have reasonable seed areas vary between around 2000 - 5000
seed_inds = np.where(np.all(np.hstack([np.array(areas) < 100000,  np.array(areas) > 200]), axis = 1))[0]




# ---------------- Examples of what you can plot----------
"""
Circularities = np.array(Circularities)
plt.figure()
plt.hist(Circularities[seed_inds],bins = 20)
plt.xlabel("Circularity")
plt.ylabel("count")
plt.title("Distribution of circularities of the analyzed seeds")

# the contour has three values, x, y coordinates, and a third value. Seems like this last which "side" of the seed the
# coordinates belongs to.

plt.figure()
for seed in np.take(seeds,seed_inds):
    plt.plot(seed["Contour"][:,0],seed["Contour"][:,1],'b')
    plt.plot(seed["Centroid"][0], seed["Centroid"][1], 'r.')

    inds = np.where(seed["Contour"][:,2] == 3)
    plt.plot(seed["Contour"][inds,0][0],seed["Contour"][inds,1][0],'r')


import matplotlib.pyplot as plt

#image = Image.open("Exempeldata/11 random pictures from same sample/IMG_9293.JPG")
#image = Image.open("Exempeldata/folder/IMG_9291.JPG")



plt.figure(figsize = (12,5))
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(image)


for seed in np.take(seeds,seed_inds):
    plt.plot(seed["Contour"][:,0],seed["Contour"][:,1])
"""

real_seeds = [seeds[i] for i in seed_inds]


areas[seed_inds][:,0]



# ------------------ Plotting the segmented seeds on top of the image ------------------
plt.figure(figsize = (12,5))
plt.subplot(1,2,1)
plt.imshow(image)
plt.subplot(1,2,2)
plt.imshow(image)

for seed in real_seeds:
    plt.plot(seed["Contour"][:,0],seed["Contour"][:,1])


import cv2
plt.figure()
# Create a binary mask of the segmented seeds
mask = np.zeros(np.shape(image))

for seed in real_seeds:
    # Fill area within contours with 1's
    cv2.fillPoly(mask, pts =[seed["Contour"][:,0:2]], color=1)

plt.imshow(mask)

# Use mask to cut out the segmented seeds from input image
# Leave all other pixels as 0
# Plot the masked image in colour
plt.figure()
masked_image = np.multiply(mask,image)
plt.imshow(masked_image)

# Plot the masked image in grayscale
plt.figure()
plt.imshow(masked_image[:,:,0],cmap = "gray")

plt.show()